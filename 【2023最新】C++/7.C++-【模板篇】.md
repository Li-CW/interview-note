# 模板
## 1 模板会写吗？写一个比较大小的模板函数
~~~cpp
include<iostream> 
using namespace std; 
template<typename type1,typename type2>//函数模板 
type1 Max(type1 a,type2 b) 
{ 
   return a > b ? a : b; 
} 
void main() 
 { 
  cout<<"Max = "<<Max(5.5,'a')<<endl; 
} 
~~~
其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a > b 这一步是会报错的。
这个时候往往需要对于 > 号进行重载，这代码量瞬间上来了。
## 2 了解模板吗？可以实现一个特定类型的吗？
C++模板是一种对类型进行参数化的工具，通常有两种形式：函数模板和类模板。函数模板针对仅参数类型不同的函数；类模板针对仅数据成员和成员函数类型不同的类。使用模板的目的就是能够让程序员编写与类型无关的代码。
在C++中，可以使用特化来为特定类型提供特定的实现。例如，我们可以为某个特定类型定义一个函数模板，然后在该类型上特化该函数模板，以提供特定于该类型的实现。
 代码参考
```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}
```
## 3 模版和泛型的区别
C++模板和泛型都是C++中的一种编程技术，用于实现通用的代码。它们的区别在于：
- 模板是在编译时进行实例化的，而泛型是在运行时进行实例化的。
- 模板可以用于实现通用的数据结构和算法，而泛型可以用于实现通用的类和函数。
- 模板可以用于实现泛型编程，而泛型可以用于实现模板编程。
## 4 模版类的作用可以介绍下吗？
C++模板类的作用是实现泛型编程，即编写一个通用的类或函数，可以适用于多种不同的数据类型。使用模板类可以避免重复编写相似的代码，提高代码的复用性和可维护性。
在C++中，模板类通常由两部分组成：模板声明和模板定义。模板声明指定了模板参数，而模板定义则实现了具体的功能。在使用模板类时，需要为每个要使用的类型提供一个对应的模板参数。
 实例
```cpp
template <typename T>
class MyClass {
public:
    void setValue(T value) {
        this->value = value;
    }
    T getValue() const {
        return value;
    }
private:
    T value;
};
```
## 5 C++11中的auto是怎么实现识别自动类型的？模板是怎么实现转化成不同类型的？
 auto
C++11中的auto关键字是用来自动推导表达式或变量的实际类型的。使用auto关键字做类型自动推导时，依次施加一下规则：如果初始化表达式是引用，则去除引用语义。
 补充
auto在C++11中是一种新的类型说明符,它可以根据初始化表达式自动推导出变量的类型。
auto的工作原理是: 
- 1. 编译器看到auto,会查看初始化表达式的类型,并将该类型作为auto变量的类型。 
- 2. 如果初始化表达式的类型可以确定,则使用该类型。如果初始化表达式包含了多个类型,则使用与初始化表达式兼容的共同类型。 
- 3. 如果无法确定类型,则报错。 
例如:
 ```
cpp auto x = 5; // x是int类型 
auto y = 1.5; // y是double类型 
auto z = x + y; // z是double类型 
std::vector&lt;int&gt; 
vec; auto itr = vec.begin(); // itr是std::vector&lt;int&gt;::iterator类型 
 ```
在上面例子中,编译器通过查看初始化表达式的类型,推导出auto变量的实际类型。 
需要注意的是,auto只在声明时确定一次变量类型,之后变量类型不再改变，并且auto变量必须初始化,才能推导出类型。 
 模板
模板是一种通用的编程技术，可以用于实现泛型编程，即编写一个通用的类或函数，可以适用于多种不同的数据类型。在C++中，模板是通过模板参数来实现的。模板参数可以是一个类型、一个整数或者一个枚举类型。在使用模板时，需要为每个要使用的类型提供一个对应的模板参数。
 参考代码
```cpp
template <typename T>
class MyClass {
public:
    void setValue(T value) {
        this->value = value;
    }
    T getValue() const {
        return value;
    }
private:
    T value;
};
```